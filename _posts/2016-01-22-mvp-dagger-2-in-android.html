---
layout: post
title: MVP + Dagger 2 on Android
date: '2016-01-22T08:07:00.001-08:00'
author: Ivan
tags:
- MVP
- ANDROID
modified_time: '2017-05-19T08:52:57.440-07:00'
blogger_id: tag:blogger.com,1999:blog-415098333644749081.post-538179353509770958
blogger_orig_url: http://invictuscode.blogspot.com/2016/01/mvp-dagger-2-in-android.html
---

MVP has become really popular in Android development. The reason is that it can help you to split logics from UI and even make your APP testable. For example, “Activity” and “Fragment” in Android sometimes cannot be written in a good way. If you don’t pay attention to activity and fragment, you might create many god objects in Android APP. Then your APP might have bad performance or some serious issues. In MVP, activity and fragment are tend to be views, they only update UI. They don’t deal with model and process data. <br />Here’s an example of view:<br /><pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DetailView</span> {</span><br />    <span class="hljs-keyword">void</span> onVideosLoaded(List&lt;Video&gt; videos);<br />    <span class="hljs-keyword">void</span> onReviewsLoaded(List&lt;Review&gt; reviews);<br />    <span class="hljs-keyword">void</span> onMovieAdded();<br />    <span class="hljs-keyword">void</span> onMovieDeleted();<br />}</code></pre>And the fragment which is responsible for updating UI implements the view.<br /><pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DetailFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DetailView</span> {</span><br />    ...<br />    <span class="hljs-annotation">@Override</span><br />    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onVideosLoaded</span>(List&lt;Video&gt; videos) {<br />        <span class="hljs-comment">// update videos on UI</span><br />    }<br /><br />    <span class="hljs-annotation">@Override</span><br />    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReviewsLoaded</span>(List&lt;Review&gt; reviews) {<br />        <span class="hljs-comment">// update reviews on UI</span><br />    }<br /><br />    <span class="hljs-annotation">@Override</span><br />    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMovieAdded</span>() {<br />        <span class="hljs-comment">// update UI</span><br />    }<br /><br />    <span class="hljs-annotation">@Override</span><br />    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMovieDeleted</span>() {<br />        <span class="hljs-comment">// update UI</span><br />    }<br />    ...<br />}</code></pre>Ok, we finished our views, but we need the most important part, Presenter! Presenter is just like a middle man who communicates with mode and view. Let’s see how it’s done!<br /><pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DetailPresenter</span> {</span><br />    <span class="hljs-keyword">private</span> DetailView detailView;   <br />    <span class="hljs-keyword">private</span> RestfulApi api;<br />    ...<br />    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadVideos</span>(<span class="hljs-keyword">int</span> id){<br />        Subscription subscription = api.getVideos(id)<br />                .subscribeOn(Schedulers.newThread())<br />                .observeOn(AndroidSchedulers.mainThread())<br />                .subscribe(videoResponse -&gt; detailView.onVideosLoaded(videoResponse.getResults()));<br />        subscriptions.add(subscription);<br />    }<br />    ...<br />}</code></pre>We create a method called “loadVideos” to load videos. When it finished loading, it will call view method to return videos. As you can see in the above code. <br /><pre class="prettyprint"><code class="language-java hljs ">detailView.onVideosLoaded(videoResponse.getResults())</code></pre>In this way, if you use detailPresenter.loadVideos in Fragment which implements DetailView, it will receive videos from onVideoLoaded callback.<br /><pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DetailFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DetailView</span> {</span><br />    ...<br /><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadVideosAndReviews</span>(Movie movie){<br />            presenter.loadVideos(movie.getId());<br />            presenter.loadReviews(movie.getId());<br />    }<br />    ...<br />}</code></pre>You might wondering now, why is this MVP to do with Dagger 2? And what is Dagger2? <br />Dagger2 is a dependency injection library for Android. It allows you to inject object into activity. So you don’t have to new classes or write bunch of constructors. If you are interested in Dagger2, you can check out <a href="http://google.github.io/dagger/">website</a> or <a href="https://www.youtube.com/watch?v=SKFB8u0-VA0">this video</a>. <br />You can use Dagger2 to provide presenter to a fragment.<br /><pre class="prettyprint"><code class="language-java hljs "><span class="hljs-annotation">@Module</span><br /><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DetailFragmentModule</span> {</span><br /><br />    <span class="hljs-keyword">private</span> Context context;<br /><br />    <span class="hljs-keyword">public</span> <span class="hljs-title">DetailFragmentModule</span>(Context context) {<br />        <span class="hljs-keyword">this</span>.context = context;<br />    }<br /><br />    <span class="hljs-annotation">@Provides</span><br />    DetailPresenter provideDetailPresenter(){<br />        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DetailPresenter(context);<br />    }<br />}</code></pre>Then define Components to inject them.<br /><pre class="prettyprint"><code class="language-java hljs "><span class="hljs-annotation">@Component</span>(modules = {DetailFragmentModule.class, ApiModule.class, DbModule.class})<br /><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DetailFragmentComponent</span> {</span><br />    <span class="hljs-keyword">void</span> inject(DetailFragment fragment);<br />}</code></pre>Third, build them in Application with modules.<br /><pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MovieApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> {</span><br />    <span class="hljs-annotation">@Override</span><br />    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span>() {<br />        <span class="hljs-keyword">super</span>.onCreate();<br />    }<br /><br />    <span class="hljs-keyword">public</span> MainFragmentComponent <span class="hljs-title">getMainFragmentComponent</span>(MainFragment mainFragment) {<br />        <span class="hljs-keyword">return</span> DaggerMainFragmentComponent.builder()<br />                .apiModule(<span class="hljs-keyword">new</span> ApiModule())<br />                .dbModule(<span class="hljs-keyword">new</span> DbModule(mainFragment.getContext()))<br />                .mainFragmentModule(<span class="hljs-keyword">new</span> MainFragmentModule(mainFragment.getContext())).build();<br />    }<br /><br />    <span class="hljs-keyword">public</span> DetailFragmentComponent <span class="hljs-title">getDetailFragmentComponent</span>(DetailFragment detailFragment){<br />        <span class="hljs-keyword">return</span> DaggerDetailFragmentComponent.builder()<br />                .apiModule(<span class="hljs-keyword">new</span> ApiModule())<br />                .dbModule(<span class="hljs-keyword">new</span> DbModule(detailFragment.getContext()))<br />                .detailFragmentModule(<span class="hljs-keyword">new</span> DetailFragmentModule(detailFragment.getContext())).build();<br />    }<br />}</code></pre>Finally, we get those injected objects in Fragment!<br /><pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DetailFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DetailView</span> {</span><br /><br />    <span class="hljs-annotation">@Inject</span><br />    DetailPresenter presenter;<br /><br />    <span class="hljs-annotation">@Nullable</span><br />    <span class="hljs-annotation">@Override</span><br />    <span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span>(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {<br />        View rootView = inflater.inflate(R.layout.fragment_detail, container, <span class="hljs-keyword">false</span>);<br />        ButterKnife.bind(<span class="hljs-keyword">this</span>, rootView);<br />        setHasOptionsMenu(<span class="hljs-keyword">true</span>);<br />        ((MovieApplication) getActivity().getApplication()).getDetailFragmentComponent(<span class="hljs-keyword">this</span>).inject(<span class="hljs-keyword">this</span>);<br />        <span class="hljs-keyword">return</span> rootView;<br />    }<br />    ...</code></pre>Using MVP with Dagger2 makes our APPs structured well and avoid huge Activity or Fragment classes, and what’s more? It can actually make your APP testable. Because you seperated data processing logics from view. Then it’s easier for us to write tests against presenters! If you are interested in Testing MVP, you can check out <a href="https://codelabs.developers.google.com/codelabs/android-testing/index.html?index=../../index#0">google codelab</a>. It contains materials which let you unstand MVP, unit testing, and UI testing on Android.<br />At last, I would like to share my Udacity android nanodegree project. In this project, I use MVP and Dagger as well. You can check it out on my <a href="https://github.com/ivanisidrowu/AND-project1n2-popmovies">github repository</a>! 